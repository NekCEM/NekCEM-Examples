c-----------------------------------------------------------------------
c
c  User specified routines:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine userinc
c-----------------------------------------------------------------------
c     Use this subroutine to compute the incident field.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'RK5'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran

      integer i,j,k
      real ky
      real yy,tt,mu,eps,eta,uinc
      complex CI
      parameter (CI = (0.0,1.0))

      tt = rktime
      do i = 1,ncemincfld
         j = cemincfld(i)
         k = cemface(j)
         yy = ym1(k,1,1,1)
         eps = permittivity(k)
         mu = permeability(k)
         eta = sqrt(mu/eps)
         ky = omega*sqrt(mu*eps)
         uinc = dble(cexp(CI*(-ky*yy-omega*tt)))
         fHN(j,3) = fHN(j,3)+uinc
         fEN(j,1) = fEN(j,1)+eta*uinc
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,myhx,myhy,myhz,myex,myey,myez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps,mu,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran

      integer i,j,k
      real tt,yy
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)
      complex z1,cfqn2,cfpn2,cfqn3,cfpn3,enpar,CI
      parameter (CI = (0.0,1.0))

      call usersol(tt,myhx,myhy,myhz,myex,myey,myez)
c     We need to set the extra PML fields too
      do i = 1,npts
         mu = permeability(i)
         eps = permittivity(i)
         pmlbn(i,1) = mu*myhx(i,1,1,1)
         pmlbn(i,2) = mu*myhy(i,1,1,1)
         pmlbn(i,3) = mu*myhz(i,1,1,1)
         pmldn(i,1) = eps*myex(i,1,1,1)
         pmldn(i,2) = eps*myey(i,1,1,1)
         pmldn(i,3) = eps*myez(i,1,1,1)
      enddo

c     We also have to initialize all of the currents
      z1 = sqrt(mu1/eps1)
c     1/2 of the parallel part of the E field at the interface (complex
c     form)
      enpar = 0.5*z1*(1.0-refl)
      do i = 1,ncemcur
         j = cemcur(i)
         fjn1(j,1) = dble((b_d/(a_d-CI*omega))*enpar)
         cfqn2 = ((a_211*b_11+CI*omega*b_21)
     $        /(omega**2-a_211+CI*omega*a_221))*enpar
         fqn2(j,1) = dble(cfqn2)
         fpn2(j,1) = dble((CI/omega)*(cfqn2+b_11*enpar))
         cfqn3 = ((a_212*b_12+CI*omega*b_22)
     $        /(omega**2-a_212+CI*omega*a_222))*enpar
         fqn3(j,1) = dble(cfqn3)
         fpn3(j,1) = dble((CI/omega)*(cfqn3+b_12*enpar))
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,myshx,myshy,myshz,mysex,mysey,mysez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'
      include 'PML'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran
      
      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      integer e,i,j,l,lx1_2
      real ky
      real yy,mu,eps,eta,d,pmlfac,pmlsigmamax
      complex CI
      parameter (CI = (0.0,1.0))

      lx1_2 = lx1/2
      do e = 1,nelt
         do j = 1,ly1
            do i = 1,lx1
c     Global number
               l = i+nx1*(j-1)+nx1*ny1*(e-1)
               eps = permittivity(l)
               mu = permeability(l)
               eta = sqrt(mu/eps)
               ky = omega*sqrt(eps*mu)
               yy = ym1(i,j,1,e)
               if (ym1(lx1_2,lx1_2,1,e).gt.0.0) then
                  if (pmltag(e).ne.0) then
                     d = pmlouter(4)-pmlinner(4)
                     pmlsigmamax =
     $                    -(pmlorder+1)*log(pmlreferr)/(2*eta*d)
                     pmlfac = (pmlsigmamax*d/(pmlorder+1))
     $                    *((yy-pmlinner(4))/d)**(pmlorder+1)
                  else
                     pmlfac = 0.0
                  endif
                  myshz(i,j,1,e) =
     $                 dble(refl*cexp(CI*(ky*yy-omega*tt)-eta*pmlfac))
                  mysex(i,j,1,e) = -eta*myshz(i,j,1,e)
               else
                  if (pmltag(e).ne.0) then
                     d = pmlinner(3)-pmlouter(3)
                     pmlsigmamax =
     $                    -(pmlorder+1)*log(pmlreferr)/(2*eta*d)
                     pmlfac = (pmlsigmamax*d/(pmlorder+1))
     $                    *((pmlinner(3)-yy)/d)**(pmlorder+1)
                  else
                     pmlfac = 0.0
                  endif
                  myshz(i,j,1,e) =
     $                 dble(tran*cexp(CI*(-ky*yy-omega*tt)-eta*pmlfac))
                  mysex(i,j,1,e) = eta*myshz(i,j,1,e)
               endif
            enddo
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
c     Add source terms to the fields given in src{e,h}{x,y,z}. Read file
c     doc/rea-file.txt for specification. Since we want to make it
c     possible to have several sources, we specify a `baseidx', relative
c     to which all parameters are read.
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'PML'
      include 'RK5'

      integer baseidx
      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt)

      real    xmin, xmax, ymin, ymax, zmin, zmax
      save    xmin, xmax, ymin, ymax, zmin, zmax

      integer fldchs
      real xx,yy,zz
      real xloc,yloc,zloc,xw,yw,zw,xwidth,ywidth,zwidth          
      real xgauss, ygauss, zgauss
      real kx,ky,kz 
      real twopi
      real tconst,tfactor,fldhere
      real wavelength
      real temporal_freq

c     Presetting
      twopi  = 2.0*pi

c     Spatial mode set
      xloc  = 0.0 ! param(66); smodty = 2: gaussian 
      yloc  = 1.5 ! param(67)
      zloc  = 0.0 ! param(68)
      xw    = 0.0 ! param(69)
      yw    = 0.0 ! param(70)
      zw    = 0.0 ! param(71)
      xwidth= 1 ! param(72)
      ywidth= 1 ! param(73)
      zwidth= 1 ! param(74)
c     Spatial mode set
      kx    = 0.0 ! param(66); smodty = 3: planewave
      ky    = 0.0 ! param(67)
      kz    = 0.0 ! param(68)

      nmscale = 1.0
      wavelength = nmscale  ! param(69)*nmscale
      temporal_freq = cspeed ! param(64)*cspeed; tmodty = 3: cosine pulse

c     Evaluate temporal modulation.
      call cosine_pulse (tfactor,rktime,twopi,temporal_freq)

c     Evaluate spatial modulation.
      xgauss = xloc + xw*rktime                                       
      ygauss = yloc + yw*rktime                                       
      zgauss = zloc + zw*rktime                                       

      npts = nx1*ny1*nz1*nelt
      do i = 1,npts         
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)
         zz = zm1(i,1,1,1)

         tconst  = tfactor*bm1(i,1,1,1) ! *fldhere

         src_x = exp(-(2.0*(xx-xgauss)/xwidth)**2)   
         src_y = exp(-(2.0*(yy-ygauss)/ywidth)**2)
         src_z = exp(-(2.0*(zz-zgauss)/zwidth)**2)

         if (imode.eq.1) then
c     TE case
            inchn(i,1) = 0
            inchn(i,2) = 0
            inchn(i,3) = src_x*src_y*src_z
            incen(i,1) = 0
            incen(i,2) = 0
            incen(i,3) = 0
            fullary(i,1,1,1) = tconst*inchn(i,3)
         elseif (imode.eq.2) then
c     TM case
            inchn(i,1) = 0
            inchn(i,2) = 0
            inchn(i,3) = 0
            incen(i,1) = 0
            incen(i,2) = 0
            incen(i,3) = src_x*src_y*src_z
            fullary(i,1,1,1) = tconst*incen(i,3)
         else
            write(*,*) 'ERROR: invalid imode in usersrc'
            call exitt
         endif
      enddo

c     Add fullary to selected field
      if (imode.eq.1) then
         fldchs = 3
      else
         fldchs = 6
      endif

      if (fldchs.eq.1) call fadd2(srchx,fullary,npts)
      if (fldchs.eq.2) call fadd2(srchy,fullary,npts)
      if (fldchs.eq.3) call fadd2(srchz,fullary,npts)
      if (fldchs.eq.4) call fadd2(srcex,fullary,npts)
      if (fldchs.eq.5) call fadd2(srcey,fullary,npts)
      if (fldchs.eq.6) call fadd2(srcez,fullary,npts)

      return
      end
c-----------------------------------------------------------------------
      subroutine cosine_pulse(tfactor,tt,twopi,param1)
c-----------------------------------------------------------------------
      real tfacfor,tt,twopi,param1

      tfactor = cos(twopi*param1*tt)             

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,ielg)
c-----------------------------------------------------------------------
c     Use this routine to set material properties.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      common /userparam/ omega,eps1,eps2,mu1,mu2,sigmagraph,refl,tran
      real omega,eps1,eps2,mu1,mu2
      complex sigmagraph,refl,tran
    
      integer ix,iy,iz,ielg,iel,nx1_2

c     Get local element number from global element number
      iel = gllel(ielg)

      nx1_2 = nx1/2
      if (ym1(nx1_2,nx1_2,1,iel).gt.0) then
         permit_r = eps1
         permea_r = mu1
      else
         permit_r = eps2
         permea_r = mu2
      endif
      permit = permit_r*permit_0
      permea = permea_r*permea_0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
c     For now piggy-back on this routine to set parameters that we need
c     for the incident field/exact solution and the graphene.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      common /userparam/
     $     omega,               ! frequency of the incident wave
     $     eps1,                ! permittivity in upper region
     $     eps2,                ! permittivity in lower region
     $     mu1,                 ! permeability in upper region
     $     mu2,                 ! permeability in lower region
     $     sigmagraph,          ! complex graphene conductivity
     $     refl,                ! complex reflection coefficient
     $     tran                 ! complex transmission coefficient

      real omega
      real eps1,eps2,mu1,mu2
      complex sigmagraph,csigma_d,csigma_cp1,csigma_cp2
      complex refl,tran,z1,z2,CI
      parameter (CI = (0.0,1.0))

      omega = 5.0
      eps1 = 1.0
      eps2 = 1.0
      mu1 = 1.0
      mu2 = 1.0

c     Set the parameters for the graphene
      a_d = 0.000e+00
      b_d = 1.499e+00
      b_cp1 = -2.599e-03
      a_211 = 4.632e+05
      a_221 = 1.090e+03
      b_11 = -1.391e+00
      b_21 = -3.125e+02
      b_cp2 = -1.049e-03
      a_212 = 4.271e+05
      a_222 = 2.742e+02
      b_12 = -7.769e-02
      b_22 = 4.268e+02

      csigma_d = b_d/(a_d-CI*omega)
      csigma_cp1 = (CI/omega)*((a_211*b_11+CI*omega*b_21)
     $     /(omega**2-a_211+CI*omega*a_221)+b_11)-b_cp1
      csigma_cp2 = (CI/omega)*((a_212*b_12+CI*omega*b_22)
     $     /(omega**2-a_212+CI*omega*a_222)+b_12)-b_cp2
      sigmagraph = csigma_d+csigma_cp1+csigma_cp2

      z1 = sqrt(mu1/eps1)
      z2 = sqrt(mu2/eps2)
      refl = (z1-z2+sigmagraph*z1*z2)/(z1+z2+sigmagraph*z1*z2)
      tran = 2*z1/(z1+z2+sigmagraph*z1*z2)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
c-----------------------------------------------------------------------
c     Use this subroutine to set the dimensions of the domain.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      integer e,f,i,j,n,nxy2
      real glmin,glmax
      real sx,sy,sz,xmid,ymid,zmid

      n = nx1*ny1*nz1*nelv

      xmin = glmin(xm1,n)
      xmax = glmax(xm1,n)
      ymin = glmin(ym1,n)
      ymax = glmax(ym1,n)
      zmin = glmin(zm1,n)
      zmax = glmax(zm1,n)

      sx = 5.0
      sy = 10.0
      if (if3d) sz = 5.0

      if (if3d) then
         do i = 1,n
            xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-(sx/2.0)
            ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-(sy/2.0)
            zm1(i,1,1,1) = sz*(zm1(i,1,1,1)-zmin)/(zmax-zmin)-(sz/2.0)
         enddo
      else
         do i = 1,n
            xm1(i,1,1,1) = sx*(xm1(i,1,1,1)-xmin)/(xmax-xmin)-(sx/2.0)
            ym1(i,1,1,1) = sy*(ym1(i,1,1,1)-ymin)/(ymax-ymin)-(sy/2.0)
         enddo
      endif

      call userfmarker

      return
      end
c-----------------------------------------------------------------------
      subroutine userfmarker
c-----------------------------------------------------------------------
c     In this routine the user should mark faces that will either need
c     the incident field added to them or have 2D materials on them.
c     Markers for the incident field should be put into the array
c     `fincmarker`; a value of 0 means that no incident field needs to
c     be added and a value of 1 means that the incident field needs to
c     be added. Markers for 2D materials should be mput into the array
c     `f2dmarker`; the currently available values are
c
c     0 -> no 2D material
c     1 -> graphene
c
c     The arrays `fincmarker` and `f2dmarker` are initialized to 0, so
c     if there is no incident field and there are no 2D materials then
c     this subroutine can be left blank.
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      logical markinc,mark2d
      integer e,f,i,j,k,nx1_2

      nx1_2 = nx1/2
      do e = 1,nelt
c     *****
c     First mark the faces where the incident field needs to be added
c     *****
         if (ym1(nx1_2,nx1_2,1,e).gt.0.0) then
            markinc = .true.
            do f = 1,nfaces
               do i = 1,nxzf
c     j is the global face number
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
c     k is the volume global number associated with face j.
                  k = cemface(j)
                  if (abs(ym1(k,1,1,1)).gt.1e-8) then
                     markinc = .false.
                     exit
                  endif
               enddo
               if (markinc) then
                  do i = 1,nxzf
                     j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                     fincmarker(j) = 1
                  enddo
               endif
            enddo
         endif
c     *****
c     Now mark the faces where there are 2d materials
c     *****
         do f = 1,nfaces
            mark2d = .true.
            do i = 1,nxzf
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
               k = cemface(j)
               if (abs(ym1(k,1,1,1)).gt.1e-8) then
                  mark2d = .false.
               endif
            enddo
            if (mark2d) then
               do i = 1,nxzf
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  f2dmarker(j) = 1
               enddo
            endif
         enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userft
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      
      call print_errors(.true.,.true.)

      return
      end
c-----------------------------------------------------------------------
