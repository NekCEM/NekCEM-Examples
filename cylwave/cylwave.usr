c-----------------------------------------------------------------------
c  USER SPECIFIED ROUTINES:
c
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c-----------------------------------------------------------------------

      subroutine userinc
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      return
      end

c-----------------------------------------------------------------------
      subroutine usersol(tt, myshx, myshy, myshz, mysex, mysey, mysez)
      ! cf. David A. de Wolf, Essentials of Electromagnetics for
      ! Engineering, Cambridge University Press, 2001
      ! Section 19.7
      ! This is the TM wave case.

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'
      include 'GEOMBOUND'

      real tt
      real myshx(lx1,ly1,lz1,lelt)
      real myshy(lx1,ly1,lz1,lelt)
      real myshz(lx1,ly1,lz1,lelt)
      real mysex(lx1,ly1,lz1,lelt)
      real mysey(lx1,ly1,lz1,lelt)
      real mysez(lx1,ly1,lz1,lelt)

      ! Mode selection
      integer m, rootidx
      real tmscale
      parameter (m = 0)         ! Index of the Bessel function
      parameter (rootidx = 1)   ! Index of Bessel J_nu root
      parameter (tmscale = 1.0) ! Scale factor of TM component

      ! Extent of domain
      real radius
      save radius

      ! Local coordinates
      real myx, myy, myz
      real rho, phi

      ! Following variables named as in reference.
      real kz, bigk, omega
      real erho, ephi, ezz
      real hrho, hphi, hzz

      ! Helper variables
      complex zfactor, tfactor, allfac

      integer zwaves

      ! Loop variables
      integer i

      ! Helper for initialize-once variables
      logical icalld
      data icalld/.false./
      save icalld

      complex iunit

      iunit = (0,1)

      n= nx1*ny1*nz1*nelt

      ! compute radius
      if (.not.icalld) then
        radius = geom_xyradius()
        xmax=glmax(xm1,n)
        ymax=glmax(ym1,n)
        zmax=glmax(zm1,n)
        xmin=glmin(xm1,n)
        ymin=glmin(ym1,n)
        zmin=glmin(zm1,n)
        icalld = .true.

        do i=1,nx1*ny1*nz1*nelt
           xx = xm1(i,1,1,1)
           yy = ym1(i,1,1,1)
           zz = zm1(i,1,1,1)
           rho = sqrt (xx**2+yy**2)
           if (rho.eq.0) then
             if (nid.eq.0) 
     $           write(6,*) 'change N: radius zero/solution infinity'
               call exitt
          ! NOTE:
          ! The analyic solution has a discontinuity at zero,
          ! so there really is no "correct" value there.
          ! (Consider approach to zero along X- and Y-axis.)
          ! The best, but still fishy, thing to do is to put 
          ! all fields to zero.

          ! Alternate is to set as below
            ezz  = 0
            erho = 0
            ephi = 0
            hrho = 0
            hphi = 0
           endif
        enddo
      endif

      zsize = zmax-zmin
      zwaves= 1.0  !   int(param(93))
      if (abs(zsize).le.1e-20) then
          kz = 0
      else
          kz = 2*pi*zwaves/zsize
      endif

      do i=1,nx1*ny1*nz1*nelt
        myx = xm1(i,1,1,1)
        myy = ym1(i,1,1,1)
        myz = zm1(i,1,1,1)

        ! find local coordinates
        rho = sqrt (myx**2 + myy**2)
        phi = atan2(myy, myx)

        ! compute solution
        bigk = bssljrt(m, rootidx)/radius
        omega = sqrt(kz**2 + bigk**2)*cspeed
            
        zfactor = cexp((0,-1)*kz*myz)
        tfactor = cexp((0,1)*omega*tt)
        allfac = tmscale * zfactor * tfactor
            
        if (rho.ne.0) then
        ezz  = real(allfac * bsslj(m, bigk*rho) * cos(m*phi))
        erho = real(allfac *(-iunit)*kz/bigk * bssljp(m, bigk*rho)
     $                     * cos(m*phi))
        ephi = real(allfac * iunit*m*kz/bigk**2/rho
     $                     * bsslj(m,bigk*rho) * sin(m*phi))
        hrho = real(allfac *(-iunit)*m*omega*permit_0/bigk**2/rho
     $                     * bsslj(m,bigk*rho) * sin(m*phi))
        hphi = real(allfac *(-iunit)*omega*permit_0/bigk
     $                     * bssljp(m,bigk*rho) * cos(m*phi))
        hzz = 0. ! TM case
           
        myshx(i,1,1,1) = cos(phi)*hrho - sin(phi)*hphi
        myshy(i,1,1,1) = sin(phi)*hrho + cos(phi)*hphi
        myshz(i,1,1,1) = hzz
        mysex(i,1,1,1) = cos(phi)*erho - sin(phi)*ephi
        mysey(i,1,1,1) = sin(phi)*erho + cos(phi)*ephi
        mysez(i,1,1,1) = ezz
        endif

      enddo

      return
      end
       
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real xsize, ysize, zsize
      real xmin,xmax,ymin,ymax,zmin,zmax
      real radius

      real e1

      integer n = 8*lelt

      radius = geom_xyradius()
      radius = int(10*radius+0.1)/10. 
      e1 = radius*radius - 1e-4

      do ie=1,nelt
      do i=1,8
        rr = xc(i,ie)*xc(i,ie) + yc(i,ie)*yc(i,ie)
        if (rr.gt.e1) then
           rr = sqrt(rr)
           rn = radius/rr
           xc(i,ie) = rn*xc(i,ie)
           yc(i,ie) = rn*yc(i,ie)
        endif
      enddo
      enddo
    1 format(2i5,1p3e18.9,a5)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2

      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      n = nx1*ny1*nz1*nelv

      xmax=glmax(xm1,n)
      ymax=glmax(ym1,n)
      zmax=glmax(zm1,n)
      xmin=glmin(xm1,n)
      ymin=glmin(ym1,n)
      zmin=glmin(zm1,n)

      sz=2*pi*xmax/(zmax-zmin)

      if (if3d) then
        do i=1,n
           zm1(i,1,1,1) =sz*(zm1(i,1,1,1)-zmin)               
        enddo
      endif

      xmax=glmax(xm1,n)
      ymax=glmax(ym1,n)
      zmax=glmax(zm1,n)
      xmin=glmin(xm1,n)
      ymin=glmin(ym1,n)
      zmin=glmin(zm1,n)

      if (nid.eq.0) write(6,*) 'xmax,ymax,zmax :: ', xmax,ymax,zmax
      if (nid.eq.0) write(6,*) 'xmin,ymin,zmin :: ', xmin,ymin,zmin

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt, myhx, myhy, myhz, myex, myey, myez)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real tt
      real myhx(lx1,ly1,lz1,lelt)
      real myhy(lx1,ly1,lz1,lelt)
      real myhz(lx1,ly1,lz1,lelt)
      real myex(lx1,ly1,lz1,lelt)
      real myey(lx1,ly1,lz1,lelt)
      real myez(lx1,ly1,lz1,lelt)

      call usersol(tt,myhx, myhy, myhz, myex, myey, myez)

      return
      end

c-----------------------------------------------------------------------
      subroutine usersrc(baseidx,srchx,srchy,srchz,srcex,srcey,srcez)
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

      real srchx(lx1,ly1,lz1,lelt),
     $     srchy(lx1,ly1,lz1,lelt),
     $     srchz(lx1,ly1,lz1,lelt),
     $     srcex(lx1,ly1,lz1,lelt),
     $     srcey(lx1,ly1,lz1,lelt),
     $     srcez(lx1,ly1,lz1,lelt) 

      integer baseidx

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'NEKUSE'

c     These don't do anything! This is a temporary measure until
c
c     https://github.com/NekCEM/NekCEM/issues/12
c
c     is resolved.
      integer ix,iy,iz,ieg

      integer i

      do i = 1,npts
         permittivity(i) = 1.0
         permeability(i) = 1.0
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
C
      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux=0.0
      uy=0.0
      uz=0.0
      temp=0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk

c ... compute errors


      if (istep.le.10.or.mod(istep,iocomm).eq.0) then

        ntott = nx1*ny1*nz1*nelt
        npts3 = nx1*ny1*nz1*nelt*3
        nsrf  = nx1*nz1*nelt*6

        if (ifsol) then
          call usersol(time,sHN(1,1),sHN(1,2),sHN(1,3),
     $                      sEN(1,1),sEN(1,2),sEN(1,3))
        else
          call rzero(sHN, npts3) 
          call rzero(sEN, npts3) 
        endif

        call sub3(ErrHN(1,1),SHN(1,1),HN(1,1),NTOTT)
        call sub3(ErrHN(1,2),SHN(1,2),HN(1,2),NTOTT)
        call sub3(ErrHN(1,3),SHN(1,3),HN(1,3),NTOTT)
        call sub3(ErrEN(1,1),SEN(1,1),EN(1,1),NTOTT)
        call sub3(ErrEN(1,2),SEN(1,2),EN(1,2),NTOTT)
        call sub3(ErrEN(1,3),SEN(1,3),EN(1,3),NTOTT)

        HXmr = glamax(ErrHN(1,1),NTOTT)
        HYmr = glamax(ErrHN(1,2),NTOTT)
        HZmr = glamax(ErrHN(1,3),NTOTT)
        EXmr = glamax(ErrEN(1,1),NTOTT)
        EYmr = glamax(ErrEN(1,2),NTOTT)
        EZmr = glamax(ErrEN(1,3),NTOTT)
 
        HXer = glsc3(ErrHN(1,1),bm1,ErrHN(1,1),NTOTT)/ volvm1
        HYer = glsc3(ErrHN(1,2),bm1,ErrHN(1,2),NTOTT)/ volvm1
        HZer = glsc3(ErrHN(1,3),bm1,ErrHN(1,3),NTOTT)/ volvm1
        EXer = glsc3(ErrEN(1,1),bm1,ErrEN(1,1),NTOTT)/ volvm1
        EYer = glsc3(ErrEN(1,2),bm1,ErrEN(1,2),NTOTT)/ volvm1
        EZer = glsc3(ErrEN(1,3),bm1,ErrEN(1,3),NTOTT)/ volvm1

        if (hxer.gt.0) hxer = sqrt(hxer)
        if (hyer.gt.0) hyer = sqrt(hyer)
        if (hzer.gt.0) hzer = sqrt(hzer)
        if (exer.gt.0) exer = sqrt(exer)
        if (eyer.gt.0) eyer = sqrt(eyer)
        if (ezer.gt.0) ezer = sqrt(ezer)

c ... print statement

        snel = nelt + .5
        snel = sqrt(snel)
        nels = snel
        nnn  = nx1-1
        npt1 = nnn*nels
        npts = nx1*ny1*nz1*nelt ! npts = npt1**ndim

        if (istep.eq.0)       cpu_p_t= 0
        if (istep.gt.0)       cpu_p_t= cpu_t/(npts*istep)
        if (istep.eq.nsteps)  cpu_p_t= glsum(cpu_p_t,1)/np

        if (nid.eq.0) then

         if (istep.eq.1) write(6,90)
         write(6,91) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXer,HYer,HZer,EXer,EYer,EZer,cpu_t,cpu_p_t
         write(6,95) ISTEP,nelt,nels,nnn,npt1,npts
     $         ,time,dt,HXmr,HYmr,HZmr,EXmr,EYmr,EZmr,cpu_t,cpu_p_t


 90      format(/,'    istep   nelt  nels  N  npt1    npts   time     
     $  dt     HXerr     HYerr     HZerr     EXerr     EYerr     EZerr   
     $  cpu_t   cpu_t_pts')
 91      format(/,i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: L2  '  )
 95      format(  i10,3i5,i5,i9,1p9e10.3,e9.2,' CPU: Linf'  )

        endif ! nid=0

      endif

      return
      end

